#!/usr/bin/env python3

import argparse
import pathlib
import time
import numpy as np
import matplotlib.pyplot as plt
import knc_loader




STEFAN_BOLTZMANN_CONSTANT = 5.67037442e-05
LIGHT_SPEED               = 2.99792458e+10




class timed(object):
    def __init__(self, message):
        self.message = message
        self.start = time.perf_counter()

    def __enter__(self):
        print('{:.<32} '.format(self.message), end='', flush=True)

    def __exit__(self, *args):
        print('{:.3}s'.format(time.perf_counter() - self.start))




def find_nearest(block, val):
    idx = np.argmin(np.abs(block - val))
    return idx, block[idx]




def load_products(filename):
    if 'prods' in filename:
        with timed('load products'):
            p = knc_loader.products(filename)
    else:
        with timed('load app'):
            a = knc_loader.app(filename)
        with timed('make products'):
            p = a.make_products()
        with timed('cache products'):
            p.save(filename.replace('chkpt', 'prods'))
    return p




def block_vertices(block, *args):
    R, Q = [x.T for x in np.meshgrid(block.radial_vertices, block.polar_vertices)]
    return R * np.sin(Q), R * np.cos(Q)




def mesh_vertices(products):
    return [block_vertices(products[k]) for k in products]




def known_fields():
    return ['rho', 'pre', 'ur', 'uq', 'scalar_density', 'scalar_concentration', 'energy', 'gamma_beta', 'temperature']




def block_field(block, field):

    sigma = STEFAN_BOLTZMANN_CONSTANT
    c = LIGHT_SPEED

    if field == 'rho':
        return block.comoving_mass_density

    elif field == 'pre':
        # Note: block.gas_pressure is in units of g / cm^3. Multiply by c^2 to
        # put it in erg / cm^3.
        return block.gas_pressure

    elif field == 'ur':
        return block.radial_four_velocity

    elif field == 'uq':
        return block.polar_four_velocity

    elif field == 'scalar_concentration':
        scalar = np.asarray(block.scalar)
        e = np.partition(scalar, 1)[1]
        scalar[scalar < 1.e-15] = 1.e-100
        return scalar

    elif field == 'scalar_density':
        # Return the lab-frame (not comoving) scalar volume density.
        u = block.radial_four_velocity
        w = block.polar_four_velocity
        G = (1.0 + u**2 + w**2)**0.5
        bscalar = np.asarray(block.scalar * block.comoving_mass_density * G)
        e = np.partition(bscalar, 1)[1]
        bscalar[bscalar < 1.e-20] = 1.e-100
        return bscalar

    elif field == 'energy':
        # Return the total gas energy. Assumes the gamma-law index is 4/3.
        p = block.gas_pressure * c**2
        d = block.comoving_mass_density
        u = block.radial_four_velocity
        w = block.polar_four_velocity
        G = (1.0 + u**2 + w**2)**0.5
        e = p / d / (4 / 3 - 1)
        h = c**2 + e + p / d
        return d * h * G**2 - p - G * d * c**2

    elif field == 'gamma_beta':
        ur = block.radial_four_velocity
        uq = block.polar_four_velocity
        return np.sqrt(ur**2 + uq**2)

    elif field == 'temperature':
        # Return the gas temperature in K. Assumes radiation dominated gas.
        a = 4.0 * sigma / c
        p = block.gas_pressure * c**2
        return (3 * p / a)**0.25

    raise ValueError(f'unknown field {field}')




def mesh_field(products, field, transform=lambda x: x):
    with np.errstate(divide='raise'):
        try:
            return [transform(block_field(products[k], field)) for k in products] # this gets caught and handled as an exception
        except FloatingPointError:
            # Ignore the 0 values of the block
            res = [np.log10(block_field(products[k], field), out=np.zeros_like(block_field(products[k], field)), where=(block_field(products[k], field) != 0)) for k in products]
            return res
    




def label_name(args):
    if args.field == 'rho':
        if args.log:
            return r'$\log_{{10}}(\rho) \ [\rm{{g/cm^3}}]$'
        else:
            return r'$\rho \ [\rm{{g/cm^3}}]$'
    elif args.field == 'temperature':
        return 'T [K]'
    elif args.field == 'gamma_beta':
        return r'$\Gamma \beta$'
    elif args.field == 'energy':
        if args.domega:
            return r'$d\tau/d\Omega \ [\rm{erg \ sr^{-1}}]$'
        else:
            return r'$\tau \ [\rm{erg}]$'
    else:
        return args.field




def plot_two_dimensional(products, args):
    vmin, vmax = eval(args.range)
    fig = plt.figure(figsize=[7, 11])
    ax1 = fig.add_subplot(1, 1, 1)

    with timed('make vertices and fields'):
        vertices = mesh_vertices(products)
        field = mesh_field(products, args.field, np.log10 if args.log else lambda x: x)
        setup = next(iter(products.config['model']))
        vmin = min([c.min() for c in field]) if vmin is None else vmin
        vmax = max([c.max() for c in field]) if vmax is None else vmax

    with timed('load plots'):
        for (x, z), c in zip(vertices, field):
            cm = ax1.pcolormesh(x, z, c, vmin=vmin, vmax=vmax, edgecolors='none', lw=0.5, cmap=args.cmap)

    if args.radius is not None:
        ax1.set_xlim(0, args.radius)
        ax1.set_ylim(-args.radius, args.radius)
    ax1.set_xlabel(r'$x \ [\rm{cm}]$')
    ax1.set_ylabel(r'$z \ [\rm{cm}]$')

    ax1.set_aspect('equal')
    fig.colorbar(cm)
    fig.subplots_adjust(left=0, right=1, top=0.9, bottom=0.05)
    fig.suptitle(r'Setup: $\mathtt{{{}}}$   {}   $t = {:.4}s$'.format(setup.replace('_', '-'), label_name(args), products.time))
    return fig




def plot_radial_profile(products, args, overplot=False, ax1=None):
    if not overplot:
        fig = plt.figure(figsize=[9, 9])
        ax1 = fig.add_subplot(1, 1, 1)
        
    field = args.field
    setup = next(iter(products.config['model']))
    if args.theta_index is None:
        r = products.radial_profile.vertices
        d = block_field(products.radial_profile[0], args.field)
    else:
        r  = products.radial_profile.vertices
        polar_vertices_size = np.asarray(mesh_vertices(products)).shape[-1]
        q = np.linspace(0, np.pi, polar_vertices_size - 1)
        tidx  = args.theta_index
        d = block_field(products.radial_profile[tidx], args.field)
        
    viewing_angle = np.pi/2 if args.theta_index is None else q[tidx]
    ax1.set_title(r'Setup: $\mathtt{{{}}}$    $\theta={:.2f}$'.format(setup.replace('_', '-'), viewing_angle), fontsize=20)
    ax1.set_ylabel(label_name(args), fontsize=15)
    ax1.plot(r, d, '-o', mfc='none', label=r'$t = {:.4}s$'.format(products.time))
    ax1.set_xlim(r[0], r[-1])
    ax1.set_xscale('log')
    ax1.set_yscale('log')
    ax1.set_xlabel(r'$r \ \rm{[cm]}$', fontsize=15)
    if not overplot:
        ax1.set_title(r'Setup: $\mathtt{{{}}}$    $\theta={:.2f}$   $t = {:.4}s$'.format(setup.replace('_', '-'), q[tidx], products.time), fontsize=20)
        return fig

def plot_angular_profile(products, args, overplot=False, ax=None):
    if not overplot:
        fig = plt.figure(figsize=[9, 9])
        ax = fig.add_subplot(1, 1, 1)
        
    field = args.field
    setup = next(iter(products.config['model']))
    polar_vertices_size = np.asarray(mesh_vertices(products)).shape[-1]
    q = np.linspace(0, 90, int( (polar_vertices_size - 1)/2) )
    field_per_angle = np.zeros(q.shape)
    for i in range(q.size):
        field_per_angle[i] = np.sum(block_field(products.radial_profile[i], args.field))
    
    ax.set_title(r'Setup: $\mathtt{{{}}}$    $t = {:.4}s$'.format(setup.replace('_', '-'), products.time), fontsize=20)
    ax.set_ylabel(label_name(args), fontsize=15)
    ax.plot(q, field_per_angle, '-o', mfc='none', label=r'$t = {:.4}s$'.format(products.time))
    
    if args.log:
        ax.set_yscale('log')
        # ax.set_xscale('log')
    ax.spines['right'].set_visible(False)
    ax.spines['top'].set_visible(False)
    ax.set_xlim(q[0], q[-1])
    ax.set_xlabel(r'$\theta $', fontsize=15)
    
    if not overplot:
        return fig
    
def plot_hist(products, args, overplot=False, ax=None, case=0):
    if not overplot:
        fig = plt.figure(figsize=[9, 9], constrained_layout=False)
        ax = fig.add_subplot(1, 1, 1)

    
    with timed('make vertices and fields'):
        r        = np.asarray(products.radial_profile.vertices)
        vertices = mesh_vertices(products)
        field    = np.asarray(mesh_field(products, args.field, np.log10 if args.log else lambda x: x))
        u        = np.asarray(mesh_field(products, "gamma_beta", np.log10 if args.log else lambda x: x))
        setup    = next(iter(products.config['model']))
        tau      = np.asarray(mesh_field(products, "energy", np.log10 if args.log else lambda x: x))
        
        polar_vertices_size = np.asarray(mesh_vertices(products)).shape[-1]
        qvertices  = np.linspace(0, np.pi, polar_vertices_size)
        dcos    = np.cos(qvertices[:-1]) - np.cos(qvertices[1: ])
        
        dV = np.zeros(field.shape)
        
        # Convert vertices back to r, q and compute each cell volume
        for idx, (x, z) in enumerate(vertices):
            r_shell = np.asarray ( (x**2 + z**2)**0.5 )
            dr      = r_shell[1: ] - r_shell[:-1]
            
            # There is an extra block in there that is not needed
            # so it is deleted
            dr = dr[:,:-1]
            dV[idx, :] = 2 * np.pi * r_shell[:-1, :-1]**2 * dr * dcos
        
        e   = tau * dV
        scalar_field = np.sqrt(1 + u**2) * dV * field
        e_k = (np.sqrt(1 + u**2) - 1) * scalar_field * LIGHT_SPEED**2 
        
    with timed('load plots'):
        w = np.diff(u).max()*1e-1
        n = int (np.ceil(u.max() - u.min())/w)
        gbs = np.logspace(np.log10(1.e-3), np.log10(u.max()), n)
        eks = np.asarray([e_k[np.where(u > gb)].sum() for gb in gbs])
        ets = np.asarray([e[np.where(u > gb)].sum() for gb in gbs])
        
        bins    =  np.arange(min(gbs), max(gbs) + w, w)
        logbins = np.logspace(np.log10(bins[0]),np.log10(bins[-1]), len(bins))

        # ax.hist(gbs, bins=gbs, weights=ets, label= r'case {}'.format(case), histtype='step', rwidth=1.0, linewidth=3.0)
        ax.hist(gbs, bins=gbs, weights=eks, alpha=0.8, label= r'case {}'.format(case), histtype='step', linewidth=3.0)
        
    plt.xscale('log')
    plt.yscale('log')
    # ax.set_xlim(u.min(), u.max())
    ax.set_xlabel(r'$\Gamma\beta $', fontsize=20)
    ax.set_ylabel(r'$E ( > \Gamma \beta) \ [\rm{erg}]$', fontsize=20)
    ax.tick_params('both', labelsize=20)
    ax.spines['right'].set_visible(False)
    ax.spines['top'].set_visible(False)
    ax.set_title(r'Setup: $\mathtt{{{}}}$  $t = {:.4}s$'.format(setup.replace('_', '-'), products.time), fontsize=20)
    
    if not overplot:
        return fig



def main():
    parser = argparse.ArgumentParser()
    parser.add_argument("filenames", nargs='+')
    parser.add_argument('-r', '--range', default='None,None', help='vmin and vmax parameters for the relief plot')
    parser.add_argument('-f', '--field', default='rho', choices=known_fields())
    parser.add_argument('-l', '--log', action='store_true')
    parser.add_argument('-c', '--cmap', default='viridis')
    parser.add_argument('--hardcopy', action='store_true')
    parser.add_argument('--output', '-o', default=None, type=str)
    parser.add_argument('--radius', default=None, type=float)
    parser.add_argument('-tidx', '--theta_index', default=None, type=int)
    parser.add_argument('--hist', default=False, action='store_true')
    parser.add_argument('--domega', default=False, action='store_true')
    args = parser.parse_args()

    if len(args.filenames) == 1:
        filename = args.filenames[0]
        products = load_products(filename)

        if args.hist:
            fig = plot_hist(products, args)
        elif args.domega:
            fig = plot_angular_profile(products, args)
        elif args.theta_index is not None:
            fig = plot_radial_profile(products, args)
        elif products.config['mesh']['num_polar_zones'] > 1:
            fig = plot_two_dimensional(products, args)
        else:
            fig = plot_radial_profile(products, args)
    else:
        plt.style.use('seaborn-dark-palette')
        fig = plt.figure(figsize=[9, 9])
        ax1 = fig.add_subplot(1, 1, 1)
        if args.hist:
            for idx, filename in enumerate(args.filenames):
                products = load_products(filename)
                
                plot_hist(products, args, overplot=True, ax=ax1, case=idx)
                
            ax1.legend(fontsize=10, loc='upper right')
        elif args.domega:
            for idx, filename in enumerate(args.filenames):
                products = load_products(filename)
                
                plot_angular_profile(products, args, overplot=True, ax=ax1)
                
            ax1.legend(fontsize=10, loc='upper right')
            # fig = plot_angular_profile(products, args)
        else:
            for filename in args.filenames:
                products = load_products(filename)
                
                plot_radial_profile(products, args, overplot=True, ax1=ax1)
                
            ax1.legend()
            

    with timed('show'):
        if args.hardcopy or args.output is not None:
            if args.output is None:
                pngname = format(pathlib.Path(filename).with_suffix('.png'))
            else:
                pngname = args.output
            print('save {}'.format(pngname))
            fig.savefig(pngname, dpi=600)
            fig.clf()
        else:
            plt.show()


if __name__ == "__main__":
    main()
